{
  "version": 3,
  "sources": ["../../@algolia/requester-browser-xhr/src/createXhrRequester.ts", "../../@algolia/client-common/src/cache/createBrowserLocalStorageCache.ts", "../../@algolia/client-common/src/cache/createNullCache.ts", "../../@algolia/client-common/src/cache/createFallbackableCache.ts", "../../@algolia/client-common/src/cache/createMemoryCache.ts", "../../@algolia/client-common/src/constants.ts", "../../@algolia/client-common/src/createAlgoliaAgent.ts", "../../@algolia/client-common/src/createAuth.ts", "../../@algolia/client-common/src/createIterablePromise.ts", "../../@algolia/client-common/src/getAlgoliaAgent.ts", "../../@algolia/client-common/src/logger/createNullLogger.ts", "../../@algolia/client-common/src/transporter/createStatefulHost.ts", "../../@algolia/client-common/src/transporter/errors.ts", "../../@algolia/client-common/src/transporter/helpers.ts", "../../@algolia/client-common/src/transporter/responses.ts", "../../@algolia/client-common/src/transporter/stackTrace.ts", "../../@algolia/client-common/src/transporter/createTransporter.ts", "../../@algolia/client-common/src/types/logger.ts", "../../algoliasearch/lite/builds/browser.ts", "../../algoliasearch/lite/src/liteClient.ts"],
  "sourcesContent": ["import type { EndRequest, Requester, Response } from '@algolia/client-common';\n\ntype Timeout = ReturnType<typeof setTimeout>;\n\nexport function createXhrRequester(): Requester {\n  function send(request: EndRequest): Promise<Response> {\n    return new Promise((resolve) => {\n      const baseRequester = new XMLHttpRequest();\n      baseRequester.open(request.method, request.url, true);\n\n      Object.keys(request.headers).forEach((key) => baseRequester.setRequestHeader(key, request.headers[key]));\n\n      const createTimeout = (timeout: number, content: string): Timeout => {\n        return setTimeout(() => {\n          baseRequester.abort();\n\n          resolve({\n            status: 0,\n            content,\n            isTimedOut: true,\n          });\n        }, timeout);\n      };\n\n      const connectTimeout = createTimeout(request.connectTimeout, 'Connection timeout');\n\n      let responseTimeout: Timeout | undefined;\n\n      baseRequester.onreadystatechange = (): void => {\n        if (baseRequester.readyState > baseRequester.OPENED && responseTimeout === undefined) {\n          clearTimeout(connectTimeout);\n\n          responseTimeout = createTimeout(request.responseTimeout, 'Socket timeout');\n        }\n      };\n\n      baseRequester.onerror = (): void => {\n        // istanbul ignore next\n        if (baseRequester.status === 0) {\n          clearTimeout(connectTimeout);\n          clearTimeout(responseTimeout!);\n\n          resolve({\n            content: baseRequester.responseText || 'Network request failed',\n            status: baseRequester.status,\n            isTimedOut: false,\n          });\n        }\n      };\n\n      baseRequester.onload = (): void => {\n        clearTimeout(connectTimeout);\n        clearTimeout(responseTimeout!);\n\n        resolve({\n          content: baseRequester.responseText,\n          status: baseRequester.status,\n          isTimedOut: false,\n        });\n      };\n\n      baseRequester.send(request.data);\n    });\n  }\n\n  return { send };\n}\n", "import type { BrowserLocalStorageCacheItem, BrowserLocalStorageOptions, Cache, CacheEvents } from '../types';\n\nexport function createBrowserLocalStorageCache(options: BrowserLocalStorageOptions): Cache {\n  let storage: Storage;\n  // We've changed the namespace to avoid conflicts with v4, as this version is a huge breaking change\n  const namespaceKey = `algolia-client-js-${options.key}`;\n\n  function getStorage(): Storage {\n    if (storage === undefined) {\n      storage = options.localStorage || window.localStorage;\n    }\n\n    return storage;\n  }\n\n  function getNamespace<TValue>(): Record<string, TValue> {\n    return JSON.parse(getStorage().getItem(namespaceKey) || '{}');\n  }\n\n  function setNamespace(namespace: Record<string, any>): void {\n    getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n  }\n\n  function removeOutdatedCacheItems(): void {\n    const timeToLive = options.timeToLive ? options.timeToLive * 1000 : null;\n    const namespace = getNamespace<BrowserLocalStorageCacheItem>();\n\n    const filteredNamespaceWithoutOldFormattedCacheItems = Object.fromEntries(\n      Object.entries(namespace).filter(([, cacheItem]) => {\n        return cacheItem.timestamp !== undefined;\n      }),\n    );\n\n    setNamespace(filteredNamespaceWithoutOldFormattedCacheItems);\n\n    if (!timeToLive) {\n      return;\n    }\n\n    const filteredNamespaceWithoutExpiredItems = Object.fromEntries(\n      Object.entries(filteredNamespaceWithoutOldFormattedCacheItems).filter(([, cacheItem]) => {\n        const currentTimestamp = new Date().getTime();\n        const isExpired = cacheItem.timestamp + timeToLive < currentTimestamp;\n\n        return !isExpired;\n      }),\n    );\n\n    setNamespace(filteredNamespaceWithoutExpiredItems);\n  }\n\n  return {\n    get<TValue>(\n      key: Record<string, any> | string,\n      defaultValue: () => Promise<TValue>,\n      events: CacheEvents<TValue> = {\n        miss: () => Promise.resolve(),\n      },\n    ): Promise<TValue> {\n      return Promise.resolve()\n        .then(() => {\n          removeOutdatedCacheItems();\n\n          return getNamespace<Promise<BrowserLocalStorageCacheItem>>()[JSON.stringify(key)];\n        })\n        .then((value) => {\n          return Promise.all([value ? value.value : defaultValue(), value !== undefined]);\n        })\n        .then(([value, exists]) => {\n          return Promise.all([value, exists || events.miss(value)]);\n        })\n        .then(([value]) => value);\n    },\n\n    set<TValue>(key: Record<string, any> | string, value: TValue): Promise<TValue> {\n      return Promise.resolve().then(() => {\n        const namespace = getNamespace();\n\n        namespace[JSON.stringify(key)] = {\n          timestamp: new Date().getTime(),\n          value,\n        };\n\n        getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n\n        return value;\n      });\n    },\n\n    delete(key: Record<string, any> | string): Promise<void> {\n      return Promise.resolve().then(() => {\n        const namespace = getNamespace();\n\n        delete namespace[JSON.stringify(key)];\n\n        getStorage().setItem(namespaceKey, JSON.stringify(namespace));\n      });\n    },\n\n    clear(): Promise<void> {\n      return Promise.resolve().then(() => {\n        getStorage().removeItem(namespaceKey);\n      });\n    },\n  };\n}\n", "import type { Cache, CacheEvents } from '../types';\n\nexport function createNullCache(): Cache {\n  return {\n    get<TValue>(\n      _key: Record<string, any> | string,\n      defaultValue: () => Promise<TValue>,\n      events: CacheEvents<TValue> = {\n        miss: (): Promise<void> => Promise.resolve(),\n      },\n    ): Promise<TValue> {\n      const value = defaultValue();\n\n      return value.then((result) => Promise.all([result, events.miss(result)])).then(([result]) => result);\n    },\n\n    set<TValue>(_key: Record<string, any> | string, value: TValue): Promise<TValue> {\n      return Promise.resolve(value);\n    },\n\n    delete(_key: Record<string, any> | string): Promise<void> {\n      return Promise.resolve();\n    },\n\n    clear(): Promise<void> {\n      return Promise.resolve();\n    },\n  };\n}\n", "import type { Cache, CacheEvents, FallbackableCacheOptions } from '../types';\nimport { createNullCache } from './createNullCache';\n\nexport function createFallbackableCache(options: FallbackableCacheOptions): Cache {\n  const caches = [...options.caches];\n  const current = caches.shift();\n\n  if (current === undefined) {\n    return createNullCache();\n  }\n\n  return {\n    get<TValue>(\n      key: Record<string, any> | string,\n      defaultValue: () => Promise<TValue>,\n      events: CacheEvents<TValue> = {\n        miss: (): Promise<void> => Promise.resolve(),\n      },\n    ): Promise<TValue> {\n      return current.get(key, defaultValue, events).catch(() => {\n        return createFallbackableCache({ caches }).get(key, defaultValue, events);\n      });\n    },\n\n    set<TValue>(key: Record<string, any> | string, value: TValue): Promise<TValue> {\n      return current.set(key, value).catch(() => {\n        return createFallbackableCache({ caches }).set(key, value);\n      });\n    },\n\n    delete(key: Record<string, any> | string): Promise<void> {\n      return current.delete(key).catch(() => {\n        return createFallbackableCache({ caches }).delete(key);\n      });\n    },\n\n    clear(): Promise<void> {\n      return current.clear().catch(() => {\n        return createFallbackableCache({ caches }).clear();\n      });\n    },\n  };\n}\n", "import type { Cache, CacheEvents, MemoryCacheOptions } from '../types';\n\nexport function createMemoryCache(options: MemoryCacheOptions = { serializable: true }): Cache {\n  let cache: Record<string, any> = {};\n\n  return {\n    get<TValue>(\n      key: Record<string, any> | string,\n      defaultValue: () => Promise<TValue>,\n      events: CacheEvents<TValue> = {\n        miss: (): Promise<void> => Promise.resolve(),\n      },\n    ): Promise<TValue> {\n      const keyAsString = JSON.stringify(key);\n\n      if (keyAsString in cache) {\n        return Promise.resolve(options.serializable ? JSON.parse(cache[keyAsString]) : cache[keyAsString]);\n      }\n\n      const promise = defaultValue();\n\n      return promise.then((value: TValue) => events.miss(value)).then(() => promise);\n    },\n\n    set<TValue>(key: Record<string, any> | string, value: TValue): Promise<TValue> {\n      cache[JSON.stringify(key)] = options.serializable ? JSON.stringify(value) : value;\n\n      return Promise.resolve(value);\n    },\n\n    delete(key: Record<string, unknown> | string): Promise<void> {\n      delete cache[JSON.stringify(key)];\n\n      return Promise.resolve();\n    },\n\n    clear(): Promise<void> {\n      cache = {};\n\n      return Promise.resolve();\n    },\n  };\n}\n", "export const DEFAULT_CONNECT_TIMEOUT_BROWSER = 1000;\nexport const DEFAULT_READ_TIMEOUT_BROWSER = 2000;\nexport const DEFAULT_WRITE_TIMEOUT_BROWSER = 30000;\n\nexport const DEFAULT_CONNECT_TIMEOUT_NODE = 2000;\nexport const DEFAULT_READ_TIMEOUT_NODE = 5000;\nexport const DEFAULT_WRITE_TIMEOUT_NODE = 30000;\n", "import type { AlgoliaAgent, AlgoliaAgentOptions } from './types';\n\nexport function createAlgoliaAgent(version: string): AlgoliaAgent {\n  const algoliaAgent = {\n    value: `Algolia for JavaScript (${version})`,\n    add(options: AlgoliaAgentOptions): AlgoliaAgent {\n      const addedAlgoliaAgent = `; ${options.segment}${options.version !== undefined ? ` (${options.version})` : ''}`;\n\n      if (algoliaAgent.value.indexOf(addedAlgoliaAgent) === -1) {\n        algoliaAgent.value = `${algoliaAgent.value}${addedAlgoliaAgent}`;\n      }\n\n      return algoliaAgent;\n    },\n  };\n\n  return algoliaAgent;\n}\n", "import type { AuthMode, Headers, QueryParameters } from './types';\n\nexport function createAuth(\n  appId: string,\n  apiKey: string,\n  authMode: AuthMode = 'WithinHeaders',\n): {\n  readonly headers: () => Headers;\n  readonly queryParameters: () => QueryParameters;\n} {\n  const credentials = {\n    'x-algolia-api-key': apiKey,\n    'x-algolia-application-id': appId,\n  };\n\n  return {\n    headers(): Headers {\n      return authMode === 'WithinHeaders' ? credentials : {};\n    },\n\n    queryParameters(): QueryParameters {\n      return authMode === 'WithinQueryParameters' ? credentials : {};\n    },\n  };\n}\n", "import type { CreateIterablePromise } from './types/createIterablePromise';\n\n/**\n * Helper: Returns the promise of a given `func` to iterate on, based on a given `validate` condition.\n *\n * @param createIterator - The createIterator options.\n * @param createIterator.func - The function to run, which returns a promise.\n * @param createIterator.validate - The validator function. It receives the resolved return of `func`.\n * @param createIterator.aggregator - The function that runs right after the `func` method has been executed, allows you to do anything with the response before `validate`.\n * @param createIterator.error - The `validate` condition to throw an error, and its message.\n * @param createIterator.timeout - The function to decide how long to wait between iterations.\n */\nexport function createIterablePromise<TResponse>({\n  func,\n  validate,\n  aggregator,\n  error,\n  timeout = (): number => 0,\n}: CreateIterablePromise<TResponse>): Promise<TResponse> {\n  const retry = (previousResponse?: TResponse | undefined): Promise<TResponse> => {\n    return new Promise<TResponse>((resolve, reject) => {\n      func(previousResponse)\n        .then(async (response) => {\n          if (aggregator) {\n            await aggregator(response);\n          }\n\n          if (await validate(response)) {\n            return resolve(response);\n          }\n\n          if (error && (await error.validate(response))) {\n            return reject(new Error(await error.message(response)));\n          }\n\n          return setTimeout(\n            () => {\n              retry(response).then(resolve).catch(reject);\n            },\n            await timeout(),\n          );\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  };\n\n  return retry();\n}\n", "import { createAlgoliaAgent } from './createAlgoliaAgent';\nimport type { AlgoliaAgent, AlgoliaAgentOptions } from './types';\n\nexport type GetAlgoliaAgent = {\n  algoliaAgents: AlgoliaAgentOptions[];\n  client: string;\n  version: string;\n};\n\nexport function getAlgoliaAgent({ algoliaAgents, client, version }: GetAlgoliaAgent): AlgoliaAgent {\n  const defaultAlgoliaAgent = createAlgoliaAgent(version).add({\n    segment: client,\n    version,\n  });\n\n  algoliaAgents.forEach((algoliaAgent) => defaultAlgoliaAgent.add(algoliaAgent));\n\n  return defaultAlgoliaAgent;\n}\n", "import type { Logger } from '../types/logger';\n\nexport function createNullLogger(): Logger {\n  return {\n    debug(_message: string, _args?: any | undefined): Promise<void> {\n      return Promise.resolve();\n    },\n    info(_message: string, _args?: any | undefined): Promise<void> {\n      return Promise.resolve();\n    },\n    error(_message: string, _args?: any | undefined): Promise<void> {\n      return Promise.resolve();\n    },\n  };\n}\n", "import type { Host, StatefulHost } from '../types';\n\n// By default, API Clients at Algolia have expiration delay of 5 mins.\n// In the JavaScript client, we have 2 mins.\nconst EXPIRATION_DELAY = 2 * 60 * 1000;\n\nexport function createStatefulHost(host: Host, status: StatefulHost['status'] = 'up'): StatefulHost {\n  const lastUpdate = Date.now();\n\n  function isUp(): boolean {\n    return status === 'up' || Date.now() - lastUpdate > EXPIRATION_DELAY;\n  }\n\n  function isTimedOut(): boolean {\n    return status === 'timed out' && Date.now() - lastUpdate <= EXPIRATION_DELAY;\n  }\n\n  return { ...host, status, lastUpdate, isUp, isTimedOut };\n}\n", "import type { Response, StackFrame } from '../types';\n\nexport class AlgoliaError extends Error {\n  override name: string = 'AlgoliaError';\n\n  constructor(message: string, name: string) {\n    super(message);\n\n    if (name) {\n      this.name = name;\n    }\n  }\n}\n\nexport class IndexNotFoundError extends AlgoliaError {\n  constructor(indexName: string) {\n    super(`${indexName} does not exist`, 'IndexNotFoundError');\n  }\n}\n\nexport class IndicesInSameAppError extends AlgoliaError {\n  constructor() {\n    super('Indices are in the same application. Use operationIndex instead.', 'IndicesInSameAppError');\n  }\n}\n\nexport class IndexAlreadyExistsError extends AlgoliaError {\n  constructor(indexName: string) {\n    super(`${indexName} index already exists.`, 'IndexAlreadyExistsError');\n  }\n}\n\nexport class ErrorWithStackTrace extends AlgoliaError {\n  stackTrace: StackFrame[];\n\n  constructor(message: string, stackTrace: StackFrame[], name: string) {\n    super(message, name);\n    // the array and object should be frozen to reflect the stackTrace at the time of the error\n    this.stackTrace = stackTrace;\n  }\n}\n\nexport class RetryError extends ErrorWithStackTrace {\n  constructor(stackTrace: StackFrame[]) {\n    super(\n      'Unreachable hosts - your application id may be incorrect. If the error persists, please reach out to the Algolia Support team: https://alg.li/support.',\n      stackTrace,\n      'RetryError',\n    );\n  }\n}\n\nexport class ApiError extends ErrorWithStackTrace {\n  status: number;\n\n  constructor(message: string, status: number, stackTrace: StackFrame[], name = 'ApiError') {\n    super(message, stackTrace, name);\n    this.status = status;\n  }\n}\n\nexport class DeserializationError extends AlgoliaError {\n  response: Response;\n\n  constructor(message: string, response: Response) {\n    super(message, 'DeserializationError');\n    this.response = response;\n  }\n}\n\nexport type DetailedErrorWithMessage = {\n  message: string;\n  label: string;\n};\n\nexport type DetailedErrorWithTypeID = {\n  id: string;\n  type: string;\n  name?: string | undefined;\n};\n\nexport type DetailedError = {\n  code: string;\n  details?: DetailedErrorWithMessage[] | DetailedErrorWithTypeID[] | undefined;\n};\n\n// DetailedApiError is only used by the ingestion client to return more informative error, other clients will use ApiClient.\nexport class DetailedApiError extends ApiError {\n  error: DetailedError;\n\n  constructor(message: string, status: number, error: DetailedError, stackTrace: StackFrame[]) {\n    super(message, status, stackTrace, 'DetailedApiError');\n    this.error = error;\n  }\n}\n", "import type { Headers, Host, QueryParameters, Request, RequestOptions, Response, StackFrame } from '../types';\nimport { ApiError, DeserializationError, DetailedApiError } from './errors';\n\nexport function shuffle<TData>(array: TData[]): TData[] {\n  const shuffledArray = array;\n\n  for (let c = array.length - 1; c > 0; c--) {\n    const b = Math.floor(Math.random() * (c + 1));\n    const a = array[c];\n\n    shuffledArray[c] = array[b];\n    shuffledArray[b] = a;\n  }\n\n  return shuffledArray;\n}\n\nexport function serializeUrl(host: Host, path: string, queryParameters: QueryParameters): string {\n  const queryParametersAsString = serializeQueryParameters(queryParameters);\n  let url = `${host.protocol}://${host.url}${host.port ? `:${host.port}` : ''}/${\n    path.charAt(0) === '/' ? path.substring(1) : path\n  }`;\n\n  if (queryParametersAsString.length) {\n    url += `?${queryParametersAsString}`;\n  }\n\n  return url;\n}\n\nexport function serializeQueryParameters(parameters: QueryParameters): string {\n  return Object.keys(parameters)\n    .filter((key) => parameters[key] !== undefined)\n    .sort()\n    .map(\n      (key) =>\n        `${key}=${encodeURIComponent(\n          Object.prototype.toString.call(parameters[key]) === '[object Array]'\n            ? parameters[key].join(',')\n            : parameters[key],\n        ).replace(/\\+/g, '%20')}`,\n    )\n    .join('&');\n}\n\nexport function serializeData(request: Request, requestOptions: RequestOptions): string | undefined {\n  if (request.method === 'GET' || (request.data === undefined && requestOptions.data === undefined)) {\n    return undefined;\n  }\n\n  const data = Array.isArray(request.data) ? request.data : { ...request.data, ...requestOptions.data };\n\n  return JSON.stringify(data);\n}\n\nexport function serializeHeaders(\n  baseHeaders: Headers,\n  requestHeaders: Headers,\n  requestOptionsHeaders?: Headers | undefined,\n): Headers {\n  const headers: Headers = {\n    Accept: 'application/json',\n    ...baseHeaders,\n    ...requestHeaders,\n    ...requestOptionsHeaders,\n  };\n  const serializedHeaders: Headers = {};\n\n  Object.keys(headers).forEach((header) => {\n    const value = headers[header];\n    serializedHeaders[header.toLowerCase()] = value;\n  });\n\n  return serializedHeaders;\n}\n\nexport function deserializeSuccess<TObject>(response: Response): TObject {\n  try {\n    return JSON.parse(response.content);\n  } catch (e) {\n    throw new DeserializationError((e as Error).message, response);\n  }\n}\n\nexport function deserializeFailure({ content, status }: Response, stackFrame: StackFrame[]): Error {\n  try {\n    const parsed = JSON.parse(content);\n    if ('error' in parsed) {\n      return new DetailedApiError(parsed.message, status, parsed.error, stackFrame);\n    }\n    return new ApiError(parsed.message, status, stackFrame);\n  } catch {\n    // ..\n  }\n  return new ApiError(content, status, stackFrame);\n}\n", "import type { Response } from '../types';\n\nexport function isNetworkError({ isTimedOut, status }: Omit<Response, 'content'>): boolean {\n  return !isTimedOut && ~~status === 0;\n}\n\nexport function isRetryable({ isTimedOut, status }: Omit<Response, 'content'>): boolean {\n  return isTimedOut || isNetworkError({ isTimedOut, status }) || (~~(status / 100) !== 2 && ~~(status / 100) !== 4);\n}\n\nexport function isSuccess({ status }: Pick<Response, 'status'>): boolean {\n  return ~~(status / 100) === 2;\n}\n", "import type { Headers, StackFrame } from '../types';\n\nexport function stackTraceWithoutCredentials(stackTrace: StackFrame[]): StackFrame[] {\n  return stackTrace.map((stackFrame) => stackFrameWithoutCredentials(stackFrame));\n}\n\nexport function stackFrameWithoutCredentials(stackFrame: StackFrame): StackFrame {\n  const modifiedHeaders: Headers = stackFrame.request.headers['x-algolia-api-key']\n    ? { 'x-algolia-api-key': '*****' }\n    : {};\n\n  return {\n    ...stackFrame,\n    request: {\n      ...stackFrame.request,\n      headers: {\n        ...stackFrame.request.headers,\n        ...modifiedHeaders,\n      },\n    },\n  };\n}\n", "import type {\n  EndRequest,\n  Host,\n  QueryParameters,\n  Request,\n  RequestOptions,\n  Response,\n  StackFrame,\n  Transporter,\n  TransporterOptions,\n} from '../types';\nimport { createStatefulHost } from './createStatefulHost';\nimport { RetryError } from './errors';\nimport { deserializeFailure, deserializeSuccess, serializeData, serializeHeaders, serializeUrl } from './helpers';\nimport { isRetryable, isSuccess } from './responses';\nimport { stackFrameWithoutCredentials, stackTraceWithoutCredentials } from './stackTrace';\n\ntype RetryableOptions = {\n  hosts: Host[];\n  getTimeout: (retryCount: number, timeout: number) => number;\n};\n\nexport function createTransporter({\n  hosts,\n  hostsCache,\n  baseHeaders,\n  logger,\n  baseQueryParameters,\n  algoliaAgent,\n  timeouts,\n  requester,\n  requestsCache,\n  responsesCache,\n}: TransporterOptions): Transporter {\n  async function createRetryableOptions(compatibleHosts: Host[]): Promise<RetryableOptions> {\n    const statefulHosts = await Promise.all(\n      compatibleHosts.map((compatibleHost) => {\n        return hostsCache.get(compatibleHost, () => {\n          return Promise.resolve(createStatefulHost(compatibleHost));\n        });\n      }),\n    );\n    const hostsUp = statefulHosts.filter((host) => host.isUp());\n    const hostsTimedOut = statefulHosts.filter((host) => host.isTimedOut());\n\n    // Note, we put the hosts that previously timed out on the end of the list.\n    const hostsAvailable = [...hostsUp, ...hostsTimedOut];\n    const compatibleHostsAvailable = hostsAvailable.length > 0 ? hostsAvailable : compatibleHosts;\n\n    return {\n      hosts: compatibleHostsAvailable,\n      getTimeout(timeoutsCount: number, baseTimeout: number): number {\n        /**\n         * Imagine that you have 4 hosts, if timeouts will increase\n         * on the following way: 1 (timed out) > 4 (timed out) > 5 (200).\n         *\n         * Note that, the very next request, we start from the previous timeout.\n         *\n         *  5 (timed out) > 6 (timed out) > 7 ...\n         *\n         * This strategy may need to be reviewed, but is the strategy on the our\n         * current v3 version.\n         */\n        const timeoutMultiplier =\n          hostsTimedOut.length === 0 && timeoutsCount === 0 ? 1 : hostsTimedOut.length + 3 + timeoutsCount;\n\n        return timeoutMultiplier * baseTimeout;\n      },\n    };\n  }\n\n  async function retryableRequest<TResponse>(\n    request: Request,\n    requestOptions: RequestOptions,\n    isRead = true,\n  ): Promise<TResponse> {\n    const stackTrace: StackFrame[] = [];\n\n    /**\n     * First we prepare the payload that do not depend from hosts.\n     */\n    const data = serializeData(request, requestOptions);\n    const headers = serializeHeaders(baseHeaders, request.headers, requestOptions.headers);\n\n    // On `GET`, the data is proxied to query parameters.\n    const dataQueryParameters: QueryParameters =\n      request.method === 'GET'\n        ? {\n            ...request.data,\n            ...requestOptions.data,\n          }\n        : {};\n\n    const queryParameters: QueryParameters = {\n      ...baseQueryParameters,\n      ...request.queryParameters,\n      ...dataQueryParameters,\n    };\n\n    if (algoliaAgent.value) {\n      queryParameters['x-algolia-agent'] = algoliaAgent.value;\n    }\n\n    if (requestOptions && requestOptions.queryParameters) {\n      for (const key of Object.keys(requestOptions.queryParameters)) {\n        // We want to keep `undefined` and `null` values,\n        // but also avoid stringifying `object`s, as they are\n        // handled in the `serializeUrl` step right after.\n        if (\n          !requestOptions.queryParameters[key] ||\n          Object.prototype.toString.call(requestOptions.queryParameters[key]) === '[object Object]'\n        ) {\n          queryParameters[key] = requestOptions.queryParameters[key];\n        } else {\n          queryParameters[key] = requestOptions.queryParameters[key].toString();\n        }\n      }\n    }\n\n    let timeoutsCount = 0;\n\n    const retry = async (\n      retryableHosts: Host[],\n      getTimeout: (timeoutsCount: number, timeout: number) => number,\n    ): Promise<TResponse> => {\n      /**\n       * We iterate on each host, until there is no host left.\n       */\n      const host = retryableHosts.pop();\n      if (host === undefined) {\n        throw new RetryError(stackTraceWithoutCredentials(stackTrace));\n      }\n\n      const timeout = { ...timeouts, ...requestOptions.timeouts };\n\n      const payload: EndRequest = {\n        data,\n        headers,\n        method: request.method,\n        url: serializeUrl(host, request.path, queryParameters),\n        connectTimeout: getTimeout(timeoutsCount, timeout.connect),\n        responseTimeout: getTimeout(timeoutsCount, isRead ? timeout.read : timeout.write),\n      };\n\n      /**\n       * The stackFrame is pushed to the stackTrace so we\n       * can have information about onRetry and onFailure\n       * decisions.\n       */\n      const pushToStackTrace = (response: Response): StackFrame => {\n        const stackFrame: StackFrame = {\n          request: payload,\n          response,\n          host,\n          triesLeft: retryableHosts.length,\n        };\n\n        stackTrace.push(stackFrame);\n\n        return stackFrame;\n      };\n\n      const response = await requester.send(payload);\n\n      if (isRetryable(response)) {\n        const stackFrame = pushToStackTrace(response);\n\n        // If response is a timeout, we increase the number of timeouts so we can increase the timeout later.\n        if (response.isTimedOut) {\n          timeoutsCount++;\n        }\n        /**\n         * Failures are individually sent to the logger, allowing\n         * the end user to debug / store stack frames even\n         * when a retry error does not happen.\n         */\n        logger.info('Retryable failure', stackFrameWithoutCredentials(stackFrame));\n\n        /**\n         * We also store the state of the host in failure cases. If the host, is\n         * down it will remain down for the next 2 minutes. In a timeout situation,\n         * this host will be added end of the list of hosts on the next request.\n         */\n        await hostsCache.set(host, createStatefulHost(host, response.isTimedOut ? 'timed out' : 'down'));\n\n        return retry(retryableHosts, getTimeout);\n      }\n\n      if (isSuccess(response)) {\n        return deserializeSuccess(response);\n      }\n\n      pushToStackTrace(response);\n      throw deserializeFailure(response, stackTrace);\n    };\n\n    /**\n     * Finally, for each retryable host perform request until we got a non\n     * retryable response. Some notes here:\n     *\n     * 1. The reverse here is applied so we can apply a `pop` later on => more performant.\n     * 2. We also get from the retryable options a timeout multiplier that is tailored\n     * for the current context.\n     */\n    const compatibleHosts = hosts.filter(\n      (host) => host.accept === 'readWrite' || (isRead ? host.accept === 'read' : host.accept === 'write'),\n    );\n    const options = await createRetryableOptions(compatibleHosts);\n\n    return retry([...options.hosts].reverse(), options.getTimeout);\n  }\n\n  function createRequest<TResponse>(request: Request, requestOptions: RequestOptions = {}): Promise<TResponse> {\n    /**\n     * A read request is either a `GET` request, or a request that we make\n     * via the `read` transporter (e.g. `search`).\n     */\n    const isRead = request.useReadTransporter || request.method === 'GET';\n    if (!isRead) {\n      /**\n       * On write requests, no cache mechanisms are applied, and we\n       * proxy the request immediately to the requester.\n       */\n      return retryableRequest<TResponse>(request, requestOptions, isRead);\n    }\n\n    const createRetryableRequest = (): Promise<TResponse> => {\n      /**\n       * Then, we prepare a function factory that contains the construction of\n       * the retryable request. At this point, we may *not* perform the actual\n       * request. But we want to have the function factory ready.\n       */\n      return retryableRequest<TResponse>(request, requestOptions);\n    };\n\n    /**\n     * Once we have the function factory ready, we need to determine of the\n     * request is \"cacheable\" - should be cached. Note that, once again,\n     * the user can force this option.\n     */\n    const cacheable = requestOptions.cacheable || request.cacheable;\n\n    /**\n     * If is not \"cacheable\", we immediately trigger the retryable request, no\n     * need to check cache implementations.\n     */\n    if (cacheable !== true) {\n      return createRetryableRequest();\n    }\n\n    /**\n     * If the request is \"cacheable\", we need to first compute the key to ask\n     * the cache implementations if this request is on progress or if the\n     * response already exists on the cache.\n     */\n    const key = {\n      request,\n      requestOptions,\n      transporter: {\n        queryParameters: baseQueryParameters,\n        headers: baseHeaders,\n      },\n    };\n\n    /**\n     * With the computed key, we first ask the responses cache\n     * implementation if this request was been resolved before.\n     */\n    return responsesCache.get(\n      key,\n      () => {\n        /**\n         * If the request has never resolved before, we actually ask if there\n         * is a current request with the same key on progress.\n         */\n        return requestsCache.get(key, () =>\n          /**\n           * Finally, if there is no request in progress with the same key,\n           * this `createRetryableRequest()` will actually trigger the\n           * retryable request.\n           */\n          requestsCache\n            .set(key, createRetryableRequest())\n            .then(\n              (response) => Promise.all([requestsCache.delete(key), response]),\n              (err) => Promise.all([requestsCache.delete(key), Promise.reject(err)]),\n            )\n            .then(([_, response]) => response),\n        );\n      },\n      {\n        /**\n         * Of course, once we get this response back from the server, we\n         * tell response cache to actually store the received response\n         * to be used later.\n         */\n        miss: (response) => responsesCache.set(key, response),\n      },\n    );\n  }\n\n  return {\n    hostsCache,\n    requester,\n    timeouts,\n    logger,\n    algoliaAgent,\n    baseHeaders,\n    baseQueryParameters,\n    hosts,\n    request: createRequest,\n    requestsCache,\n    responsesCache,\n  };\n}\n", "export const LogLevelEnum: Readonly<Record<string, LogLevelType>> = {\n  Debug: 1,\n  Info: 2,\n  Error: 3,\n};\n\nexport type LogLevelType = 1 | 2 | 3;\n\nexport type Logger = {\n  /**\n   * Logs debug messages.\n   */\n  debug: (message: string, args?: any | undefined) => Promise<void>;\n\n  /**\n   * Logs info messages.\n   */\n  info: (message: string, args?: any | undefined) => Promise<void>;\n\n  /**\n   * Logs error messages.\n   */\n  error: (message: string, args?: any | undefined) => Promise<void>;\n};\n", "// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.\n\nimport { createXhrRequester } from '@algolia/requester-browser-xhr';\n\nimport {\n  createBrowserLocalStorageCache,\n  createFallbackableCache,\n  createMemoryCache,\n  createNullLogger,\n} from '@algolia/client-common';\n\nimport type { ClientOptions } from '@algolia/client-common';\n\nimport { apiClientVersion, createLiteClient } from '../src/liteClient';\n\nexport { apiClientVersion } from '../src/liteClient';\n\nexport * from '../model';\n\nexport function liteClient(appId: string, apiKey: string, options?: ClientOptions | undefined): LiteClient {\n  if (!appId || typeof appId !== 'string') {\n    throw new Error('`appId` is missing.');\n  }\n\n  if (!apiKey || typeof apiKey !== 'string') {\n    throw new Error('`apiKey` is missing.');\n  }\n\n  return createLiteClient({\n    appId,\n    apiKey,\n    timeouts: {\n      connect: 1000,\n      read: 2000,\n      write: 30000,\n    },\n    logger: createNullLogger(),\n    requester: createXhrRequester(),\n    algoliaAgents: [{ segment: 'Browser' }],\n    authMode: 'WithinQueryParameters',\n    responsesCache: createMemoryCache(),\n    requestsCache: createMemoryCache({ serializable: false }),\n    hostsCache: createFallbackableCache({\n      caches: [createBrowserLocalStorageCache({ key: `${apiClientVersion}-${appId}` }), createMemoryCache()],\n    }),\n    ...options,\n  });\n}\n\nexport type LiteClient = ReturnType<typeof createLiteClient>;\n", "// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.\n\nimport type {\n  CreateClientOptions,\n  Headers,\n  Host,\n  QueryParameters,\n  Request,\n  RequestOptions,\n} from '@algolia/client-common';\nimport { createAuth, createTransporter, getAlgoliaAgent, shuffle } from '@algolia/client-common';\n\nimport type { GetRecommendationsParams } from '../model/getRecommendationsParams';\nimport type { GetRecommendationsResponse } from '../model/getRecommendationsResponse';\nimport type { SearchMethodParams } from '../model/searchMethodParams';\nimport type { SearchResponses } from '../model/searchResponses';\n\nimport type {\n  CustomPostProps,\n  LegacyGetRecommendationsParams,\n  LegacySearchMethodProps,\n} from '../model/clientMethodProps';\n\nimport type { SearchForFacetValuesResponse } from '../model/searchForFacetValuesResponse';\nimport type { SearchResponse } from '../model/searchResponse';\n\nexport const apiClientVersion = '5.35.0';\n\nfunction getDefaultHosts(appId: string): Host[] {\n  return (\n    [\n      {\n        url: `${appId}-dsn.algolia.net`,\n        accept: 'read',\n        protocol: 'https',\n      },\n      {\n        url: `${appId}.algolia.net`,\n        accept: 'write',\n        protocol: 'https',\n      },\n    ] as Host[]\n  ).concat(\n    shuffle([\n      {\n        url: `${appId}-1.algolianet.com`,\n        accept: 'readWrite',\n        protocol: 'https',\n      },\n      {\n        url: `${appId}-2.algolianet.com`,\n        accept: 'readWrite',\n        protocol: 'https',\n      },\n      {\n        url: `${appId}-3.algolianet.com`,\n        accept: 'readWrite',\n        protocol: 'https',\n      },\n    ]),\n  );\n}\n\nexport function createLiteClient({\n  appId: appIdOption,\n  apiKey: apiKeyOption,\n  authMode,\n  algoliaAgents,\n  ...options\n}: CreateClientOptions) {\n  const auth = createAuth(appIdOption, apiKeyOption, authMode);\n  const transporter = createTransporter({\n    hosts: getDefaultHosts(appIdOption),\n    ...options,\n    algoliaAgent: getAlgoliaAgent({\n      algoliaAgents,\n      client: 'Lite',\n      version: apiClientVersion,\n    }),\n    baseHeaders: {\n      'content-type': 'text/plain',\n      ...auth.headers(),\n      ...options.baseHeaders,\n    },\n    baseQueryParameters: {\n      ...auth.queryParameters(),\n      ...options.baseQueryParameters,\n    },\n  });\n\n  return {\n    transporter,\n\n    /**\n     * The `appId` currently in use.\n     */\n    appId: appIdOption,\n\n    /**\n     * The `apiKey` currently in use.\n     */\n    apiKey: apiKeyOption,\n\n    /**\n     * Clears the cache of the transporter for the `requestsCache` and `responsesCache` properties.\n     */\n    clearCache(): Promise<void> {\n      return Promise.all([transporter.requestsCache.clear(), transporter.responsesCache.clear()]).then(() => undefined);\n    },\n\n    /**\n     * Get the value of the `algoliaAgent`, used by our libraries internally and telemetry system.\n     */\n    get _ua(): string {\n      return transporter.algoliaAgent.value;\n    },\n\n    /**\n     * Adds a `segment` to the `x-algolia-agent` sent with every requests.\n     *\n     * @param segment - The algolia agent (user-agent) segment to add.\n     * @param version - The version of the agent.\n     */\n    addAlgoliaAgent(segment: string, version?: string | undefined): void {\n      transporter.algoliaAgent.add({ segment, version });\n    },\n\n    /**\n     * Helper method to switch the API key used to authenticate the requests.\n     *\n     * @param params - Method params.\n     * @param params.apiKey - The new API Key to use.\n     */\n    setClientApiKey({ apiKey }: { apiKey: string }): void {\n      if (!authMode || authMode === 'WithinHeaders') {\n        transporter.baseHeaders['x-algolia-api-key'] = apiKey;\n      } else {\n        transporter.baseQueryParameters['x-algolia-api-key'] = apiKey;\n      }\n    },\n\n    /**\n     * Helper: calls the `search` method but with certainty that we will only request Algolia records (hits) and not facets.\n     * Disclaimer: We don't assert that the parameters you pass to this method only contains `hits` requests to prevent impacting search performances, this helper is purely for typing purposes.\n     *\n     * @summary Search multiple indices for `hits`.\n     * @param searchMethodParams - Query requests and strategies. Results will be received in the same order as the queries.\n     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.\n     */\n    searchForHits<T>(\n      searchMethodParams: LegacySearchMethodProps | SearchMethodParams,\n      requestOptions?: RequestOptions | undefined,\n    ): Promise<{ results: Array<SearchResponse<T>> }> {\n      return this.search(searchMethodParams, requestOptions) as Promise<{ results: Array<SearchResponse<T>> }>;\n    },\n\n    /**\n     * Helper: calls the `search` method but with certainty that we will only request Algolia facets and not records (hits).\n     * Disclaimer: We don't assert that the parameters you pass to this method only contains `facets` requests to prevent impacting search performances, this helper is purely for typing purposes.\n     *\n     * @summary Search multiple indices for `facets`.\n     * @param searchMethodParams - Query requests and strategies. Results will be received in the same order as the queries.\n     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.\n     */\n    searchForFacets(\n      searchMethodParams: LegacySearchMethodProps | SearchMethodParams,\n      requestOptions?: RequestOptions | undefined,\n    ): Promise<{ results: Array<SearchForFacetValuesResponse> }> {\n      return this.search(searchMethodParams, requestOptions) as Promise<{\n        results: Array<SearchForFacetValuesResponse>;\n      }>;\n    },\n    /**\n     * This method lets you send requests to the Algolia REST API.\n     * @param customPost - The customPost object.\n     * @param customPost.path - Path of the endpoint, for example `1/newFeature`.\n     * @param customPost.parameters - Query parameters to apply to the current query.\n     * @param customPost.body - Parameters to send with the custom request.\n     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.\n     */\n    customPost(\n      { path, parameters, body }: CustomPostProps,\n      requestOptions?: RequestOptions,\n    ): Promise<Record<string, unknown>> {\n      if (!path) {\n        throw new Error('Parameter `path` is required when calling `customPost`.');\n      }\n\n      const requestPath = '/{path}'.replace('{path}', path);\n      const headers: Headers = {};\n      const queryParameters: QueryParameters = parameters ? parameters : {};\n\n      const request: Request = {\n        method: 'POST',\n        path: requestPath,\n        queryParameters,\n        headers,\n        data: body ? body : {},\n      };\n\n      return transporter.request(request, requestOptions);\n    },\n\n    /**\n     * Retrieves recommendations from selected AI models.\n     *\n     * Required API Key ACLs:\n     *  - search\n     * @param getRecommendationsParams - The getRecommendationsParams object.\n     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.\n     */\n    getRecommendations(\n      getRecommendationsParams: GetRecommendationsParams | LegacyGetRecommendationsParams,\n      requestOptions?: RequestOptions,\n    ): Promise<GetRecommendationsResponse> {\n      if (getRecommendationsParams && Array.isArray(getRecommendationsParams)) {\n        const newSignatureRequest: GetRecommendationsParams = {\n          requests: getRecommendationsParams,\n        };\n\n        getRecommendationsParams = newSignatureRequest;\n      }\n\n      if (!getRecommendationsParams) {\n        throw new Error('Parameter `getRecommendationsParams` is required when calling `getRecommendations`.');\n      }\n\n      if (!getRecommendationsParams.requests) {\n        throw new Error('Parameter `getRecommendationsParams.requests` is required when calling `getRecommendations`.');\n      }\n\n      const requestPath = '/1/indexes/*/recommendations';\n      const headers: Headers = {};\n      const queryParameters: QueryParameters = {};\n\n      const request: Request = {\n        method: 'POST',\n        path: requestPath,\n        queryParameters,\n        headers,\n        data: getRecommendationsParams,\n        useReadTransporter: true,\n        cacheable: true,\n      };\n\n      return transporter.request(request, requestOptions);\n    },\n\n    /**\n     * Sends multiple search requests to one or more indices.  This can be useful in these cases:  - Different indices for different purposes, such as, one index for products, another one for marketing content. - Multiple searches to the same index—for example, with different filters.  Use the helper `searchForHits` or `searchForFacets` to get the results in a more convenient format, if you already know the return type you want.\n     *\n     * Required API Key ACLs:\n     *  - search\n     * @param searchMethodParams - Muli-search request body. Results are returned in the same order as the requests.\n     * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.\n     */\n    search<T>(\n      searchMethodParams: SearchMethodParams | LegacySearchMethodProps,\n      requestOptions?: RequestOptions,\n    ): Promise<SearchResponses<T>> {\n      if (searchMethodParams && Array.isArray(searchMethodParams)) {\n        const newSignatureRequest: SearchMethodParams = {\n          requests: searchMethodParams.map(({ params, ...legacyRequest }) => {\n            if (legacyRequest.type === 'facet') {\n              return {\n                ...legacyRequest,\n                ...params,\n                type: 'facet',\n              };\n            }\n\n            return {\n              ...legacyRequest,\n              ...params,\n              facet: undefined,\n              maxFacetHits: undefined,\n              facetQuery: undefined,\n            };\n          }),\n        };\n\n        searchMethodParams = newSignatureRequest;\n      }\n\n      if (!searchMethodParams) {\n        throw new Error('Parameter `searchMethodParams` is required when calling `search`.');\n      }\n\n      if (!searchMethodParams.requests) {\n        throw new Error('Parameter `searchMethodParams.requests` is required when calling `search`.');\n      }\n\n      const requestPath = '/1/indexes/*/queries';\n      const headers: Headers = {};\n      const queryParameters: QueryParameters = {};\n\n      const request: Request = {\n        method: 'POST',\n        path: requestPath,\n        queryParameters,\n        headers,\n        data: searchMethodParams,\n        useReadTransporter: true,\n        cacheable: true,\n      };\n\n      return transporter.request(request, requestOptions);\n    },\n  };\n}\n"],
  "mappings": "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",
  "names": ["createXhrRequester", "send", "request", "resolve", "baseRequester", "key", "createTimeout", "timeout", "content", "connectTimeout", "responseTimeout", "response"]
}
